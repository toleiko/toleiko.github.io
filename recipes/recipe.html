<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Recipe - toleiko</title>
  <meta name="description" content="Recipe details from toleiko's collection">
  <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
  <!-- Title Section Container -->
  <div id="titleSection"></div>
  
  <!-- Main Content -->
  <div class="content">
    <div style="margin-bottom: 2rem;">
      <button onclick="history.back()" class="nav-button nav-button--outline nav-button--medium">
        ‚Üê Back to Recipes
      </button>
    </div>

    <!-- Recipe Details Container -->
    <div id="recipeDetails">
      <div class="loading-message">Loading recipe...</div>
    </div>
  </div>

  <!-- Load Templates -->
  <script src="../js/templates.js"></script>
  <script>
    // Load the title section
    loadTemplate('titleSection', 'titleSection', {
      title: 'Recipe',
      searchPlaceholder: 'Search recipes...',
      showSearch: false,
      showDropdown: true,
      dropdownItems: [
        {
          text: 'Home',
          href: 'https://toleiko.ca',
          icon: 'üè†'
        },
        {
          text: 'Projects',
          href: 'https://toleiko.ca/projects',
          icon: 'üöÄ'
        },
        {
          text: 'Recipes',
          href: 'https://toleiko.ca/recipes',
          icon: 'üç≤'
        }
      ]
    });

    // Get recipe filename from URL parameter
    function getRecipeFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('recipe');
    }

    // Load and display recipe details
    async function loadRecipeDetails() {
      const recipeFile = getRecipeFromURL();
      
      if (!recipeFile) {
        document.getElementById('recipeDetails').innerHTML = '<p>No recipe specified.</p>';
        return;
      }

      try {
        const response = await fetch(`database/${recipeFile}.json`);
        if (!response.ok) {
          throw new Error(`Recipe not found: ${recipeFile}`);
        }

        const recipe = await response.json();
        displayRecipe(recipe);
      } catch (error) {
        console.error('Error loading recipe:', error);
        document.getElementById('recipeDetails').innerHTML = `<p>Error loading recipe: ${error.message}</p>`;
      }
    }

    // Store original recipe for scaling calculations
    let originalRecipe = null;
    let currentServings = null;

    // Display recipe with proper formatting
    function displayRecipe(recipe) {
      const container = document.getElementById('recipeDetails');
      
      // Store original recipe data
      originalRecipe = JSON.parse(JSON.stringify(recipe)); // Deep clone
      currentServings = recipe.servings;
      
      // Update page title
      document.title = `${recipe.name} - toleiko`;
      document.querySelector('.page-title').textContent = recipe.name;

      container.innerHTML = `
        <div class="recipe-detail">
          <div class="recipe-header">
            <h1>${recipe.name}</h1>
            <div class="recipe-meta">
              <span class="prep-time">‚è±Ô∏è ${recipe.duration} ${recipe.duration === 1 ? 'hour' : 'hours'}</span>
              <div class="servings-control">
                <label for="servingsInput">üçΩÔ∏è Servings:</label>
                <div class="servings-input-group">
                  <button onclick="adjustServings(-1)" class="serving-btn">‚àí</button>
                  <input type="number" id="servingsInput" value="${recipe.servings}" min="1" max="50" onchange="updateServings()">
                  <button onclick="adjustServings(1)" class="serving-btn">+</button>
                </div>
                <span class="original-servings">(Originally ${recipe.servings})</span>
              </div>
            </div>
            ${recipe.tags ? `
              <div class="recipe-tags">
                ${recipe.tags.map(tag => `<span class="recipe-tag">${tag}</span>`).join('')}
              </div>
            ` : ''}
          </div>

          <div class="recipe-content">
            <div id="ingredientsSection">${formatIngredients(recipe.ingredients, currentServings)}</div>
            ${formatInstructions(recipe.instructions)}
            ${recipe.additional_context ? formatAdditionalContext(recipe.additional_context) : ''}
          </div>
        </div>
      `;
    }

    // Serving size adjustment functions
    function adjustServings(change) {
      const input = document.getElementById('servingsInput');
      const newValue = Math.max(1, Math.min(50, parseInt(input.value) + change));
      input.value = newValue;
      updateServings();
    }

    function updateServings() {
      const input = document.getElementById('servingsInput');
      const newServings = parseInt(input.value);
      if (newServings && newServings > 0) {
        currentServings = newServings;
        // Update ingredients section with scaled amounts
        document.getElementById('ingredientsSection').innerHTML = formatIngredients(originalRecipe.ingredients, currentServings);
      }
    }

    // Parse and scale ingredient quantities
    function scaleIngredient(ingredient, scaleFactor) {
      // Regular expressions to match various quantity formats
      const patterns = [
        // Fractions: 1/2, 2/3, etc.
        /^(\d+\/\d+)\s*([‚Äì-])\s*(.+)$/,
        // Decimal numbers: 1.5, 2.25, etc.
        /^(\d+\.?\d*)\s*([‚Äì-])\s*(.+)$/,
        // Mixed numbers: 1 1/2, 2 3/4, etc.
        /^(\d+\s+\d+\/\d+)\s*([‚Äì-])\s*(.+)$/,
        // Ranges: 2-3, 4-6, etc.
        /^(\d+\.?\d*)\s*[-‚Äì]\s*(\d+\.?\d*)\s*([‚Äì-])\s*(.+)$/,
        // Simple numbers at start: 2 tbsp, 3 cups, etc.
        /^(\d+\.?\d*)\s+(.+)$/
      ];

      for (const pattern of patterns) {
        const match = ingredient.match(pattern);
        if (match) {
          if (pattern.source.includes('[-‚Äì].*[-‚Äì]')) {
            // Range pattern (e.g., "2-3 ‚Äì Onions")
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            const scaledMin = (min * scaleFactor).toFixed(2).replace(/\.?0+$/, '');
            const scaledMax = (max * scaleFactor).toFixed(2).replace(/\.?0+$/, '');
            return `${scaledMin}‚Äì${scaledMax} ${match[3]} ${match[4]}`;
          } else if (match[2] === '‚Äì' || match[2] === '-') {
            // Standard format with dash (e.g., "2 ‚Äì tbsp Oil")
            const quantity = parseQuantity(match[1]);
            const scaledQuantity = formatScaledQuantity(quantity * scaleFactor);
            return `${scaledQuantity} ${match[2]} ${match[3]}`;
          } else {
            // Simple format without dash (e.g., "2 tbsp oil")
            const quantity = parseQuantity(match[1]);
            const scaledQuantity = formatScaledQuantity(quantity * scaleFactor);
            return `${scaledQuantity} ${match[2]}`;
          }
        }
      }
      
      // If no pattern matches, return original (for items like "Salt to taste")
      return ingredient;
    }

    // Parse various quantity formats to decimal
    function parseQuantity(quantityStr) {
      quantityStr = quantityStr.trim();
      
      // Handle fractions like "1/2"
      if (quantityStr.includes('/')) {
        const parts = quantityStr.split(/\s+/);
        let total = 0;
        
        for (const part of parts) {
          if (part.includes('/')) {
            const [num, den] = part.split('/');
            total += parseInt(num) / parseInt(den);
          } else {
            total += parseInt(part);
          }
        }
        return total;
      }
      
      return parseFloat(quantityStr);
    }

    // Format scaled quantity back to nice fractions when possible
    function formatScaledQuantity(quantity) {
      const commonFractions = {
        0.125: '1/8', 0.25: '1/4', 0.333: '1/3', 0.375: '3/8',
        0.5: '1/2', 0.625: '5/8', 0.667: '2/3', 0.75: '3/4', 0.875: '7/8'
      };
      
      const wholeNumber = Math.floor(quantity);
      const decimal = quantity - wholeNumber;
      
      // Check if decimal part matches a common fraction
      for (const [dec, frac] of Object.entries(commonFractions)) {
        if (Math.abs(decimal - parseFloat(dec)) < 0.01) {
          return wholeNumber > 0 ? `${wholeNumber} ${frac}` : frac;
        }
      }
      
      // If no common fraction matches, use decimal (rounded to reasonable precision)
      return quantity % 1 === 0 ? quantity.toString() : quantity.toFixed(2).replace(/\.?0+$/, '');
    }

    // Format ingredients (handle both simple arrays and sectioned objects)
    function formatIngredients(ingredients, servings = null) {
      if (!ingredients) return '';

      const scaleFactor = servings && originalRecipe ? servings / originalRecipe.servings : 1;

      if (Array.isArray(ingredients)) {
        // Simple format: array of strings
        return `
          <div class="recipe-section">
            <h3>Ingredients</h3>
            <ul class="ingredient-list">
              ${ingredients.map(ingredient => `<li>${scaleIngredient(ingredient, scaleFactor)}</li>`).join('')}
            </ul>
          </div>
        `;
      } else if (typeof ingredients === 'object') {
        // Complex format: object with sections
        return `
          <div class="recipe-section">
            <h3>Ingredients</h3>
            ${Object.entries(ingredients).map(([sectionName, items]) => `
              <div class="ingredient-section">
                <h4>${sectionName}</h4>
                <ul class="ingredient-list indented">
                  ${items.map(item => `<li>${scaleIngredient(item, scaleFactor)}</li>`).join('')}
                </ul>
              </div>
            `).join('')}
          </div>
        `;
      }
      
      return '';
    }

    // Format instructions (handle both simple arrays and sectioned objects)
    function formatInstructions(instructions) {
      if (!instructions) return '';

      if (Array.isArray(instructions)) {
        // Simple format: array of strings
        return `
          <div class="recipe-section">
            <h3>Instructions</h3>
            <ol class="instruction-list">
              ${instructions.map(instruction => `<li>${instruction}</li>`).join('')}
            </ol>
          </div>
        `;
      } else if (typeof instructions === 'object') {
        // Complex format: object with sections
        return `
          <div class="recipe-section">
            <h3>Instructions</h3>
            ${Object.entries(instructions).map(([sectionName, steps]) => `
              <div class="instruction-section">
                <h4>${sectionName}</h4>
                <ol class="instruction-list indented">
                  ${steps.map(step => `<li>${step}</li>`).join('')}
                </ol>
              </div>
            `).join('')}
          </div>
        `;
      }
      
      return '';
    }

    // Format additional context
    function formatAdditionalContext(context) {
      const sections = [];
      
      if (context.source && context.source.trim()) {
        sections.push(`<p><strong>Source:</strong> ${context.source}</p>`);
      }
      
      if (context.story && context.story.trim()) {
        sections.push(`<p><strong>Story:</strong> ${context.story}</p>`);
      }
      
      if (context.tips && context.tips.trim()) {
        sections.push(`<p><strong>Tips:</strong> ${context.tips}</p>`);
      }

      if (sections.length === 0) return '';

      return `
        <div class="recipe-section">
          <h3>Additional Information</h3>
          <div class="additional-context">
            ${sections.join('')}
          </div>
        </div>
      `;
    }

    // Load recipe when page loads
    loadRecipeDetails();
  </script>
</body>
</html>
