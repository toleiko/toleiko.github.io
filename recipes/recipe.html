<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Recipe - toleiko</title>
  <meta name="description" content="Recipe details from toleiko's collection">
  <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
  <!-- Title Section Container -->
  <div id="titleSection"></div>
  
  <!-- Main Content -->
  <div class="content">
    <div style="margin-bottom: 2rem;">
      <button onclick="history.back()" class="nav-button nav-button--outline nav-button--medium">
        ‚Üê Back to Recipes
      </button>
    </div>

    <!-- Recipe Details Container -->
    <div id="recipeDetails">
      <div class="loading-message">Loading recipe...</div>
    </div>
  </div>

  <!-- Load Templates -->
  <script src="../js/templates.js"></script>
  <script>
    // Load the title section
    loadTemplate('titleSection', 'titleSection', {
      title: 'Recipe',
      searchPlaceholder: 'Search recipes...',
      showSearch: false,
      showDropdown: true,
      dropdownItems: [
        {
          text: 'Home',
          href: 'https://toleiko.ca',
          icon: 'üè†'
        },
        {
          text: 'Projects',
          href: 'https://toleiko.ca/projects',
          icon: 'üöÄ'
        },
        {
          text: 'Recipes',
          href: 'https://toleiko.ca/recipes',
          icon: 'üç≤'
        }
      ]
    });

    // Get recipe filename from URL parameter
    function getRecipeFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('recipe');
    }

    // Load and display recipe details
    async function loadRecipeDetails() {
      const recipeFile = getRecipeFromURL();
      
      if (!recipeFile) {
        document.getElementById('recipeDetails').innerHTML = '<p>No recipe specified.</p>';
        return;
      }

      try {
        const response = await fetch(`database/${recipeFile}.json`);
        if (!response.ok) {
          throw new Error(`Recipe not found: ${recipeFile}`);
        }

        const recipe = await response.json();
        displayRecipe(recipe);
      } catch (error) {
        console.error('Error loading recipe:', error);
        document.getElementById('recipeDetails').innerHTML = `<p>Error loading recipe: ${error.message}</p>`;
      }
    }

    // Store original recipe for scaling calculations
    let originalRecipe = null;
    let currentServings = null;

    // Display recipe with proper formatting
    function displayRecipe(recipe) {
      const container = document.getElementById('recipeDetails');
      
      // Store original recipe data
      originalRecipe = JSON.parse(JSON.stringify(recipe)); // Deep clone
      currentServings = recipe.servings;
      
      // Update page title
      document.title = `${recipe.name} - toleiko`;

      container.innerHTML = `
        <div class="recipe-detail">
          <div class="recipe-header">
            <h1>${recipe.name}</h1>
            <div class="recipe-meta">
              <span class="prep-time">‚è±Ô∏è ${recipe.duration} ${recipe.duration === 1 ? 'hour' : 'hours'}</span>
              <div class="servings-control">
                <label for="servingsInput">üçΩÔ∏è Servings:</label>
                <div class="servings-input-group">
                  <button onclick="adjustServings(-1)" class="serving-btn">‚àí</button>
                  <input type="number" id="servingsInput" value="${recipe.servings}" min="1" max="50" onchange="updateServings()">
                  <button onclick="adjustServings(1)" class="serving-btn">+</button>
                </div>
                <span class="original-servings">(Originally ${recipe.servings})</span>
              </div>
            </div>
            ${recipe.tags ? `
              <div class="recipe-tags">
                ${recipe.tags.map(tag => `<span class="recipe-tag">${tag}</span>`).join('')}
              </div>
            ` : ''}
          </div>

          <div class="recipe-content">
            <div id="ingredientsSection">${formatIngredients(recipe.ingredients, currentServings)}</div>
            ${formatInstructions(recipe.instructions)}
            ${recipe.additional_context ? formatAdditionalContext(recipe.additional_context) : ''}
          </div>
        </div>
      `;
    }

    // Serving size adjustment functions
    function adjustServings(change) {
      const input = document.getElementById('servingsInput');
      const newValue = Math.max(1, Math.min(50, parseInt(input.value) + change));
      input.value = newValue;
      updateServings();
    }

    function updateServings() {
      const input = document.getElementById('servingsInput');
      const newServings = parseInt(input.value);
      if (newServings && newServings > 0) {
        currentServings = newServings;
        // Update ingredients section with scaled amounts
        document.getElementById('ingredientsSection').innerHTML = formatIngredients(originalRecipe.ingredients, currentServings);
      }
    }

    // Parse and scale ingredient quantities
    function scaleIngredient(ingredient, scaleFactor) {
      console.log('Scaling ingredient:', ingredient, 'with factor:', scaleFactor);
      
      // Regular expressions to match various quantity formats (order matters!)
      const patterns = [
        // Mixed numbers with unit and dash: 1 1/2 cup ‚Äì description, etc.
        /^(\d+\s+\d+\/\d+)\s+([^‚Äì-]+)\s*([‚Äì-])\s*(.+)$/,
        // Simple fractions with unit and dash: 1/2 cup ‚Äì description, etc.
        /^(\d+\/\d+)\s+([^‚Äì-]+)\s*([‚Äì-])\s*(.+)$/,
        // Decimal numbers with unit and dash: 1.5 cups ‚Äì description, etc.
        /^(\d+\.?\d*)\s+([^‚Äì-]+)\s*([‚Äì-])\s*(.+)$/,
        // Ranges with dash: 2-3 ‚Äì onions, etc.
        /^(\d+\.?\d*)\s*[-‚Äì]\s*(\d+\.?\d*)\s*([‚Äì-])\s*(.+)$/,
        // Simple numbers without dash: 2 tbsp, 3 cups, etc.
        /^(\d+\.?\d*)\s+(.+)$/
      ];

      for (const pattern of patterns) {
        const match = ingredient.match(pattern);
        if (match) {
          console.log('Pattern matched:', pattern.source, 'Match:', match);
          
          if (pattern.source.includes('[-‚Äì].*[-‚Äì]')) {
            // Range pattern (e.g., "2-3 ‚Äì Onions")
            const min = parseFloat(match[1]);
            const max = parseFloat(match[2]);
            const scaledMin = (min * scaleFactor).toFixed(2).replace(/\.?0+$/, '');
            const scaledMax = (max * scaleFactor).toFixed(2).replace(/\.?0+$/, '');
            const result = `${scaledMin}‚Äì${scaledMax} ${match[3]} ${match[4]}`;
            console.log('Range result:', result);
            return result;
          } else if (match.length === 5) {
            // New format with unit: quantity + unit + dash + description (e.g., "1 1/2 cup ‚Äì Chicken")
            const quantity = parseQuantity(match[1]);
            console.log('Parsed quantity:', quantity, 'from:', match[1]);
            const scaledQuantity = formatScaledQuantity(quantity * scaleFactor);
            console.log('Scaled quantity:', scaledQuantity);
            const unit = match[2];
            const dash = match[3];
            const description = match[4];
            const result = `${scaledQuantity} ${unit} ${dash} ${description}`;
            console.log('Unit format result:', result);
            return result;
          } else if (match[2] === '‚Äì' || match[2] === '-') {
            // Old format with dash (e.g., "2 ‚Äì tbsp Oil")
            const quantity = parseQuantity(match[1]);
            console.log('Parsed quantity:', quantity, 'from:', match[1]);
            const scaledQuantity = formatScaledQuantity(quantity * scaleFactor);
            console.log('Scaled quantity:', scaledQuantity);
            const result = `${scaledQuantity} ${match[2]} ${match[3]}`;
            console.log('Old format result:', result);
            return result;
          } else {
            // Simple format without dash (e.g., "2 tbsp oil")
            const quantity = parseQuantity(match[1]);
            console.log('Parsed quantity:', quantity, 'from:', match[1]);
            const scaledQuantity = formatScaledQuantity(quantity * scaleFactor);
            console.log('Scaled quantity:', scaledQuantity);
            const result = `${scaledQuantity} ${match[2]}`;
            console.log('Simple result:', result);
            return result;
          }
        }
      }
      
      // If no pattern matches, return original (for items like "Salt to taste")
      return ingredient;
    }

    // Parse various quantity formats to decimal
    function parseQuantity(quantityStr) {
      quantityStr = quantityStr.trim();
      console.log('Parsing quantity:', quantityStr);
      
      // Handle mixed numbers like "1 1/2" (one and a half)
      const mixedNumberMatch = quantityStr.match(/^(\d+)\s+(\d+)\/(\d+)$/);
      if (mixedNumberMatch) {
        console.log('Mixed number match:', mixedNumberMatch);
        const wholeNumber = parseInt(mixedNumberMatch[1]);
        const numerator = parseInt(mixedNumberMatch[2]);
        const denominator = parseInt(mixedNumberMatch[3]);
        const result = wholeNumber + (numerator / denominator);
        console.log('Mixed number result:', result);
        return result;
      }
      
      // Handle simple fractions like "1/2"
      const fractionMatch = quantityStr.match(/^(\d+)\/(\d+)$/);
      if (fractionMatch) {
        console.log('Fraction match:', fractionMatch);
        const numerator = parseInt(fractionMatch[1]);
        const denominator = parseInt(fractionMatch[2]);
        const result = numerator / denominator;
        console.log('Fraction result:', result);
        return result;
      }
      
      // Handle decimal numbers
      const result = parseFloat(quantityStr);
      console.log('Decimal result:', result);
      return result;
    }

    // Format scaled quantity back to nice fractions when possible
    function formatScaledQuantity(quantity) {
      const commonFractions = {
        0.125: '1/8', 0.25: '1/4', 0.333: '1/3', 0.375: '3/8',
        0.5: '1/2', 0.625: '5/8', 0.667: '2/3', 0.75: '3/4', 0.875: '7/8'
      };
      
      const wholeNumber = Math.floor(quantity);
      const decimal = quantity - wholeNumber;
      
      // Check if decimal part matches a common fraction
      for (const [dec, frac] of Object.entries(commonFractions)) {
        if (Math.abs(decimal - parseFloat(dec)) < 0.01) {
          return wholeNumber > 0 ? `${wholeNumber} ${frac}` : frac;
        }
      }
      
      // If no common fraction matches, use decimal (rounded to reasonable precision)
      return quantity % 1 === 0 ? quantity.toString() : quantity.toFixed(2).replace(/\.?0+$/, '');
    }

    // Format individual ingredient with two-column layout
    function formatIngredientItem(ingredient, scaleFactor) {
      const scaledIngredient = scaleIngredient(ingredient, scaleFactor);
      
      // Split on the dash separator
      const dashIndex = scaledIngredient.indexOf('‚Äì') !== -1 ? scaledIngredient.indexOf('‚Äì') : scaledIngredient.indexOf('-');
      
      if (dashIndex > 0) {
        const quantity = scaledIngredient.substring(0, dashIndex).trim();
        const description = scaledIngredient.substring(dashIndex + 1).trim();
        
        return `
          <div class="ingredient-item">
            <div class="ingredient-quantity">${quantity}</div>
            <div class="ingredient-description">${description}</div>
          </div>
        `;
      } else {
        // If no dash found, display as single item
        return `
          <div class="ingredient-item">
            <div class="ingredient-quantity"></div>
            <div class="ingredient-description">${scaledIngredient}</div>
          </div>
        `;
      }
    }

    // Format ingredients (handle both simple arrays and sectioned objects)
    function formatIngredients(ingredients, servings = null) {
      if (!ingredients) return '';

      const scaleFactor = servings && originalRecipe ? servings / originalRecipe.servings : 1;

      if (Array.isArray(ingredients)) {
        // Simple format: array of strings
        return `
          <div class="recipe-section">
            <h3>Ingredients</h3>
            <div class="ingredient-list">
              ${ingredients.map(ingredient => formatIngredientItem(ingredient, scaleFactor)).join('')}
            </div>
          </div>
        `;
      } else if (typeof ingredients === 'object') {
        // Complex format: object with sections
        return `
          <div class="recipe-section">
            <h3>Ingredients</h3>
            ${Object.entries(ingredients).map(([sectionName, items]) => `
              <div class="ingredient-section">
                <h4>${sectionName}</h4>
                <div class="ingredient-list indented">
                  ${items.map(item => formatIngredientItem(item, scaleFactor)).join('')}
                </div>
              </div>
            `).join('')}
          </div>
        `;
      }
      
      return '';
    }

    // Format instructions (handle both simple arrays and sectioned objects)
    function formatInstructions(instructions) {
      if (!instructions) return '';

      if (Array.isArray(instructions)) {
        // Simple format: array of strings
        return `
          <div class="recipe-section">
            <h3>Instructions</h3>
            <ol class="instruction-list">
              ${instructions.map(instruction => `<li>${instruction}</li>`).join('')}
            </ol>
          </div>
        `;
      } else if (typeof instructions === 'object') {
        // Complex format: object with sections
        return `
          <div class="recipe-section">
            <h3>Instructions</h3>
            ${Object.entries(instructions).map(([sectionName, steps]) => `
              <div class="instruction-section">
                <h4>${sectionName}</h4>
                <ol class="instruction-list indented">
                  ${steps.map(step => `<li>${step}</li>`).join('')}
                </ol>
              </div>
            `).join('')}
          </div>
        `;
      }
      
      return '';
    }

    // Format additional context
    function formatAdditionalContext(context) {
      const sections = [];
      
      if (context.source && context.source.trim()) {
        sections.push(`<p><strong>Source:</strong> ${context.source}</p>`);
      }
      
      if (context.story && context.story.trim()) {
        sections.push(`<p><strong>Story:</strong> ${context.story}</p>`);
      }
      
      if (context.tips && context.tips.trim()) {
        sections.push(`<p><strong>Tips:</strong> ${context.tips}</p>`);
      }

      if (sections.length === 0) return '';

      return `
        <div class="recipe-section">
          <h3>Additional Information</h3>
          <div class="additional-context">
            ${sections.join('')}
          </div>
        </div>
      `;
    }

    // Test function for debugging
    function testScaling() {
      const testIngredient = "1 1/2 cup ‚Äì Chicken or Pork, cut small";
      console.log('Testing ingredient:', testIngredient);
      const scaledResult = scaleIngredient(testIngredient, 2);
      console.log('Scaled x2:', scaledResult);
      const scaledResult3 = scaleIngredient(testIngredient, 3);
      console.log('Scaled x3:', scaledResult3);
    }
    
    // Make test function available globally
    window.testScaling = testScaling;

    // Load recipe when page loads
    loadRecipeDetails();
  </script>
</body>
</html>
